<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Calendar.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Calendar.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, {
  useState,
  useEffect,
  useRef,
  useMemo,
  useCallback,
} from "react";
import "./Calendar.css";
import { Calendar, momentLocalizer } from "react-big-calendar";
import moment from "moment";
import "react-big-calendar/lib/css/react-big-calendar.css";
import {
  generateAimHighAppointments,
  generateCoolPrimeAppointments,
  generateEDIAppointment,
} from "../hooks/windowEventCalc";
import ClickableDateCell from "../components/ClickableCell";
import { eventPropGetter } from "../hooks/eventPropGetter";
import ToggleAppointment from "./Appointment";
import "../components/useAppointmentFilters.css";
import CustomToolbar from "../components/CustomToolbar";
import Alert from "../components/Alert";
import PopUp from "../components/PopUp";
import RebookingForm from "../components/RebookingForm";
import { CiCalendar } from "react-icons/ci";
import { useData } from "../hooks/DataContext";

/**
 * Calendar component that renders the main calendar view and handles appointment management.
 * Includes functionality for booking, editing, deleting appointments,
 * blocking dates, searching patients, and managing visit windows.
 * @component
 * @example
 * &lt;Route path="/calendar" element={&lt;MyCalendar />} />
 * @returns {JSX.Element} The Calendar component that renders the main calendar view and handles appointment management.
 */

const MyCalendar = () => {
  const [view, setView] = useState("month");
  const [date, setDate] = useState(new Date());
  const [searchPatientId, setSearchPatientId] = useState("");
  const [windowEvents, setWindowEvents] = useState([]);
  const [currentPatient, setCurrentPatient] = useState(null);
  const [alert, setAlert] = useState(null);
  const [popupOpen, setPopupOpen] = useState(false);
  const [outsideWindowPopupOpen, setOutsideWindowPopupOpen] = useState(false);
  const [pendingAppointment, setPendingAppointment] = useState(null);
  const [eventToDelete, setEventToDelete] = useState(null);
  const [selectedEvent, setSelectedEvent] = useState(null);
  const [editedInfo, setEditedInfo] = useState(null);

  const [appOpen, setAppOpen] = useState(false);

  const [showRebookingForm, setShowRebookingForm] = useState(false);
  const [rebookPopupOpen, setRebookPopupOpen] = useState(false);
  const [eventToRebook, setEventToRebook] = useState(null);

  /**
   * State to manage blocked dates
   * @type {Array&lt;{start: Date, end: Date}>}
   * @returns {void}
   * 
   */
  const [blockedDates, setBlockedDates] = useState(() => {
    const stored = localStorage.getItem("blockedDates");
    if (stored) {
      try {
        const parsed = JSON.parse(stored);
        return parsed.map((evt ) => ({
          start: new Date(evt.start),
          end: evt.end ? new Date(evt.end) : new Date(evt.start),
        }));
      } catch (e) {
        console.error("Failed to parse blockedDates from storage:", e);
        return [];
      }
    }

    return [];
  }); 

  const [selectedDate, setSelectedDate] = useState("");
  const [showBlockedDates, setShowBlockedDates] = useState(false);

  const isFirstRender = useRef(true);

  const { data: apiUserList, loading, error, updatePatient } = useData();
  const [userList, setUserList] = useState([]);

  /**
   * Effect to map API user data with booked events from localStorage
   * and set the combined user list state.
   * @returns {void}
   *
   */
  // Grab from local storage and in storedList
  useEffect(() => {
    if (apiUserList &amp;&amp; Array.isArray(apiUserList)) {
      
      let storedBookedEvents = [];
      try {
        storedBookedEvents =
          JSON.parse(localStorage.getItem("bookedEvents")) || [];
      } catch (error) {
        console.error("Error parsing bookedEvents from localStorage:", error);
        storedBookedEvents = [];
      }

      const mapped = apiUserList.map((rec) => {
        const id = String(rec.record_id || "");

        const patientBooked = storedBookedEvents
          .filter((evt) => String(evt.patientId) === id)
          .sort((a, b) => (Number(a.visitNum) || 0) - (Number(b.visitNum) || 0));

        if (patientBooked.length > 0) {
        // Show latest booked visit as booked
        const latest = patientBooked[patientBooked.length - 1];
          return {
            ...latest,
            type: "booked",
            visitNum: Number(latest.visitNum) || 1,
            DOB: rec.nicu_dob || latest.DOB || "",
            site:
              {
                1: "CUMH",
                2: "Coombe",
                3: "Rotunda",
              }[rec.nicu_dag] || "Unknown",
            Study: latest.Study || ["AIMHIGH"],
          };
        }

        return {
          id,
          type: "window",
          visitNum: 1,
          OutOfArea: rec.nicu_ooa === "1",
          DOB: rec.nicu_dob || "",
          site:
            {
              1: "CUMH",
              2: "Coombe",
              3: "Rotunda",
            }[rec.nicu_dag] || "Unknown",
          Study: ["AIMHIGH"],
          DaysEarly: rec.nicu_days_early ? Number(rec.nicu_days_early) : 0,
          Info: "",
          notes: rec.nicu_email || "",
          email: rec.nicu_email || "",
          participantGroup: rec.nicu_participant_group || "",
        };
      });

      setUserList(mapped);
    } else {
      setUserList([]);
    }
  }, [apiUserList]);

  /**
   * Effect to load blocked dates from localStorage on component mount.
   * @returns {void}
   */

  useEffect(() => {
    const storedDates = localStorage.getItem("blockedDates");
    if (storedDates) {
      setBlockedDates(JSON.parse(storedDates));
    }
  }, []);


  useEffect(() => {
    localStorage.setItem("blockedDates", JSON.stringify(blockedDates));
  }, [blockedDates]);

  /**
   * 
   * Handles selecting an event on the calendar.
   * 
   * @param {Object} event - The event object that was selected.
   * @param {string} event.type - The type of the event (e.g., "booked", "window").
   * @param {string} event.title - The title of the event.
   * @param {Date} event.start - The start date/time of the event.
   * @param {Date} event.end - The end date/time of the event.
   * @param {string} event.room - The room assigned to the event.
   * @param {boolean} event.noShow - Indicates if the event was marked as a no-show.
   * @param {string} event.noShowComment - Comments related to the no-show status. 
   * @returns {void}
   */
  // Open popup when clicking an event
  const handleSelectEvent = (event) => {
    // So only booked events can be altered
    if (event.type === "booked") {
      setSelectedEvent(event);
      // Copy all editable properties into editedInfo state
      setEditedInfo({
        title: event.title || "",
        start: event.start,
        end: event.end,
        room: event.room || "",
        noShow: event.noShow || false,
        noShowComment: event.noShowComment || "",
      });
    }
  };


  /**
   * Handles blocking a selected date on the calendar.
   * @returns {void}
   */

  //Blocking dates so they cannot be booked
  const handleBlockDate = () => {
    if (selectedDate) {
      const startOfDay = moment(selectedDate).startOf("day").toISOString();
      const endOfDay = moment(selectedDate).endOf("day").toISOString();

      const blockedEvent = {
        title: "Blocked",
        start: startOfDay,
        end: endOfDay,
        allDay: true,
        blocked: true,
      };

      setBlockedDates((prev) => {
        const alreadyBlocked = prev.some((evt) =>
          moment(evt.start).isSame(startOfDay, "day")
        );
        if (!alreadyBlocked) {
          const updated = [...prev, blockedEvent];
          localStorage.setItem("blockedDates", JSON.stringify(updated));
          return updated;
        }
        return prev;
      });

      setAlert({
        message: `Blocked ${moment(selectedDate).format("YYYY-MM-DD")}`,
        type: "success",
      });
    } else {
      setAlert({ message: "Please select a date to block", type: "error" });
    }
  };
  
  /**
   * Handles unblocking a previously blocked date on the calendar.
   * @returns {void}
   */
  //Unblock previously blocked dates
  const handleUnBlockDate = () => {
  try {
    if (!selectedDate) {
      setAlert({ message: "Please select a date to unblock", type: "error" });
      return;
    }

    const startOfDay = moment(selectedDate).startOf("day");

    setBlockedDates((prev) => {
      const safePrev = Array.isArray(prev) ? prev : [];

      // Filter out the blocked event that matches the selected date
      const updated = safePrev.filter((evt) => {
        const evtStart = evt?.start ? moment(evt.start) : null;
        return !evtStart?.isSame(startOfDay, "day");
      });

      // Save updated blocked dates to localStorage safely
      try {
        localStorage.setItem("blockedDates", JSON.stringify(updated));
      } catch (e) {
        console.error("Error updating localStorage:", e);
      }

      // Alert user
      if (updated.length !== safePrev.length) {
        setAlert({
          message: `Unblocked ${startOfDay.format("YYYY-MM-DD")}`,
          type: "success",
        });
      } else {
        setAlert({
          message: "Selected date was not blocked",
          type: "warning",
        });
      }

      return updated;
    });
  } catch (error) {
    console.error("Error in handleUnblockDate:", error);
    setAlert({ message: "An error occurred while unblocking", type: "error" });
  }
};

/**
 * Toggles the display of blocked dates on the calendar.
 * @returns {void}
 */
  const handleShowBlockedDates = () => {
    setShowBlockedDates((prev) => !prev);
  };

  /**
   * Handles the change of selected date from the date input.
   * @param {Object} event - The event object from the date input change.
   * @param {string} event.target.value - The new selected date value.
   * @return {void} 
   */
  const handleDateChange = (event) => {
    setSelectedDate(event.target.value);
  };

  const blockedEventGetter = (event) => {
    if (event.blocked) {
      return {
        className: "rbc-event-blocked",
      };
    }
    return {};
  };

  /**
   * Handles combining event properties for styling and blocked status.
   * 
   * @param {Object} event - The event object to get properties for. 
   * @param {string} event.type - The type of the event (e.g., "booked", "window").
   * @param {string} event.title - The title of the event.
   * @param {Date} event.start - The start date/time of the event.
   * @param {Date} event.end - The end date/time of the event.
   * @param {boolean} event.blocked - Indicates if the event is blocked.
   * @param {string} event.room - The room assigned to the event.
   * @param {boolean} event.noShow - Indicates if the event was marked as a no-show.
   * @param {string} event.noShowComment - Comments related to the no-show status.
   *  @returns {void}
   */
  const combinedEventGetter = (event) => {
    const blockedProps = blockedEventGetter(event);
    const styleProps = eventPropGetter(event);

    return {
      ...styleProps,
      ...blockedProps,
    };
  };

  /**
   * Handles changes to the no-show checkbox in the event edit form.
   * @param {React.ChangeEvent&lt;HTMLInputElement>} e - The change event from the checkbox.
   * @return {void} 
   */
  const handleNoShowChange = (e) => {
    const newNoShowStatus = e.target.checked;
    setEditedInfo((prev) => ({
      ...prev,
      noShow: newNoShowStatus,
    }));

    if (newNoShowStatus) {
      setShowRebookingForm(true);
      setAppOpen(false);
    } else {
      setShowRebookingForm(false);
    }
  };

  /**
   * Handles updating an existing event in the booked events list.
   * @param {Object} updatedEvent - The event object with updated details.
   * @param {string} updatedEvent.id - The unique identifier of the event.
   * @param {string} updatedEvent.title - The title of the event.
   * @param {Date} updatedEvent.start - The start date/time of the event.
   * @param {Date} updatedEvent.end - The end date/time of the event.
   * @param {string} updatedEvent.room - The room assigned to the event.
   * @param {boolean} updatedEvent.noShow - Indicates if the event was marked as a no-show.
   * @param {string} updatedEvent.noShowComment - Comments related to the no-show status.
   * @return {void} 
   */

  const handleUpdateEvent = (updatedEvent) => {
    const updatedBooked = bookedEvents.map((event) =>
      event.id === updatedEvent.id ? updatedEvent : event
    );
    setBookedEvents(updatedBooked);
    localStorage.setItem("bookedEvents", JSON.stringify(updatedBooked));
  };

  useEffect(() => {
    if (!editedInfo || isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }

    if (editedInfo.show &amp;&amp; !editedInfo.noShow) {
      openBookingFormWithPrefill(selectedEvent);
    }
  }, [editedInfo?.noShow, selectedEvent, editedInfo]);

  const openBookingFormWithPrefill = (event) => {
    setSelectedEvent(event);
    setShowRebookingForm(true);
  };

  /**
   * Handles saving edited event information.
   * @returns {void}
   */
  // Save when editing event info
  const saveEditedInfo = () => {
    if (!selectedEvent || !editedInfo) return;
    // Prepare updated event object
    const updatedEvent = {
      ...selectedEvent,
      title: editedInfo.title,
      start: new Date(editedInfo.start),
      end: new Date(editedInfo.end),
      noShow: editedInfo.noShow || false,
      noShowComment: editedInfo.noShowComment || "",
      room: editedInfo.room,
    };

    /**
     * Handles updating bookedEvents or windowEvents based on the selected event type.
     * @returns {void}
     */
    // Update bookedEvents or windowEvents depending on type
    if (selectedEvent.type === "booked") {
      const updatedBooked = bookedEvents.map((event) =>
        event.id === selectedEvent.id &amp;&amp;
        new Date(event.start).getTime() ===
          new Date(selectedEvent.start).getTime()
          ? updatedEvent
          : event
      );
      // Set booked events when updated
      setBookedEvents(updatedBooked);
      // Store in local storage
      localStorage.setItem("bookedEvents", JSON.stringify(updatedBooked));
    } else if (selectedEvent.type === "window") {
      const updatedWindows = windowEvents.map((event) =>
        event.id === selectedEvent.id &amp;&amp;
        new Date(event.start).getTime() ===
          new Date(selectedEvent.start).getTime()
          ? updatedEvent
          : event
      );
      setWindowEvents(updatedWindows);
    }

    /**
     * Handles opening the rebooking popup if the event was marked as a no-show.
     * @returns {void}
     */
    // If edited info and noshow selected
    if (editedInfo.noShow) {
      setEventToRebook(updatedEvent);
      setRebookPopupOpen(true);
      setAppOpen(false);
    }

    // Save edited info and close popup
    setEditedInfo((prev) => ({
      ...prev,
      noShow: false,
      show: false,
    }));
    setShowRebookingForm(false);
    setAppOpen(false);
    closePopup();
  };

  // Close popup
  const closePopup = () => {
    setSelectedEvent(null);
    setEditedInfo("");
  };

  /**
   * Handles searching for a patient by their ID.
   * @returns {void}
   */
  // Search patient by ID
  const handleSearchWindow = () => {
    const patient = userList.find((p) => p.id === searchPatientId.trim());
    if (!patient) {
      setAlert({ message: "Patient with that ID not found", type: "error" });
      setCurrentPatient(null);
      setWindowEvents([]);
      return;
    }

    // If trying to book another appointment
    if (["booked"].includes(patient.type)) {
      setAlert({
        message: "This patient's visit is already booked or scheduled.",
        type: "error",
      });
      setCurrentPatient(null);
      setWindowEvents([]);
      return;
    }

    /**
     * Handles generating visit windows for the found patient and navigating to booked appointments if they exist.
     * Sets the current patient and window events state.
     * Loops through the patient's studies to generate visit windows.
     * Validates and formats the generated visit windows before setting them in state.
     * Updates the calendar view to navigate to booked appointments or visit windows as appropriate.
     * Displays alerts based on the patient's appointment status.
     * @returns {void}
     */
    // Set current patient info
    setCurrentPatient(patient);
    const birthDate = new Date(patient.DOB);
    const babyDaysEarly = patient.DaysEarly;
    const studies = Array.isArray(patient.Study)
      ? patient.Study
      : [patient.Study];
    let studyWindows = [];

    // Loops through studies -> Create visit window
    studies.forEach((study) => {
      let generated = [];

      try {
         if (study === "AIMHIGH") {
          generated = generateAimHighAppointments(birthDate, babyDaysEarly);
        } else if (study === "COOLPRIME") {
          generated = generateCoolPrimeAppointments(birthDate, babyDaysEarly);
        } else if (study === "EDI") {
          generated = generateEDIAppointment(birthDate, babyDaysEarly);
        }
      } catch (error) {
        console.error(`Error generating appointments for study ${study}:`, error);
        generated = [];
      }

      if (!Array.isArray(generated)) generated = [];
     

      // Generate = study windows and display and set them
      const studyEvents = generated
      .filter(
        (event) =>
          event &amp;&amp;
          event.type === "window" &amp;&amp;
          event.start &amp;&amp;
          event.end &amp;&amp;
          !isNaN(new Date(event.start)) &amp;&amp;
          !isNaN(new Date(event.end))
      )
      .map((event) => {
        const startDate = new Date(event.start);
        const endDate = new Date(event.end);
        endDate.setDate(endDate.getDate() + 1); // add one day safely

        return {
          ...event,
          title: `${study} Visit Window`,
          Name: patient.Name,
          id: patient.id,
          start: startDate,
          end: endDate, // Add by one as the calendar is exclusive to the last date
        };
      });


      studyWindows = [...studyWindows, ...studyEvents];
    });

    if (studyWindows.length === 0){
      setAlert({
        message: "No visit windows currently avaliable for this patient",
        type: "info",
      });
      setWindowEvents([]);
      return;
    }

    setWindowEvents(studyWindows);

    /**
     * Handles checking for existing booked appointments for the patient and navigating the calendar accordingly.
     * If booked appointments exist, navigates to the next upcoming appointment or the earliest one.
     * If no booked appointments exist, navigates to the first visit window.
     * Displays alerts based on the navigation action taken.
     * @returns {void}
     */

    //  Check if patient has existing booked appointments and navigate to them
    const patientBookedAppointments = bookedEvents
      .filter((appointment) => appointment.patientId === patient.id)
      .map((appointment) => ({
        ...appointment,
        start: appointment.start ? new Date(appointment.start) : null,
        end: appointment.end ? new Date(appointment.end) : null,
      }));


    if (patientBookedAppointments.length > 0) {
      // Sort appointments by date and find the next upcoming appointment or the earliest one
      const now = new Date();
      const sortedAppointments = patientBookedAppointments.sort(
        (a, b) => new Date(a.start) - new Date(b.start)
      );

      // Try to find next upcoming appointment, otherwise use the first one
      const nextAppointment =
        sortedAppointments.find((apt) => new Date(apt.start) >= now) ||
        sortedAppointments[0];

      // Navigate calendar to the appointment date
      setDate(new Date(nextAppointment.start));
      setView("month");

      setAlert({
        message: `Found patient: ${patient.Name} - Navigated to booked appointment`,
        type: "success",
      });
    } else if (studyWindows.length > 0) {
      // If no booked appointments, navigate to the first visit window
      const sortedWindows = studyWindows.sort(
        (a, b) => new Date(a.start) - new Date(b.start)
      );
      const firstWindow = sortedWindows[0];

      // Navigate calendar to the window start date
      setDate(new Date(firstWindow.start));
      setView("day"); // Switch to day view to show the window clearly

      setAlert({
        message: `Found patient: - Showing visit window`,
        type: "success",
      });
    }
  };

  /**
   * Handles checking if an appointment falls within the patient's visit windows.
   * 
   * @param {Object} appointment - The appointment object to check. 
   * @param {Object} patient - The patient object containing visit window information. 
   * @returns {boolean} True if the appointment is within any visit window, false otherwise.
   */
  // If booking within study window
  const isAppointmentWithinVisitWindow = (appointment, patient) => {
    const birthDate = new Date(patient.DOB);
    const daysEarly = patient.DaysEarly ?? 0;
    const visitNum = patient.visitNum;
    const studies = Array.isArray(patient.Study)
      ? patient.Study
      : [patient.Study];

    // Get the appointment date (ignoring time)
    const appointmentDate = new Date(appointment.start);
    appointmentDate.setHours(0, 0, 0, 0); // Reset to start of day

    for (const study of studies) {
      let windows = [];
      if (study === "AIMHIGH") {
        windows = generateAimHighAppointments(birthDate, daysEarly, visitNum);
      } else if (study === "COOLPRIME") {
        windows = generateCoolPrimeAppointments(birthDate, daysEarly, visitNum);
      } else if (study === "EDI") {
        windows = generateEDIAppointment(birthDate, daysEarly, visitNum);
      }

      for (const window of windows) {
        // Get window start and end dates (ignoring time)
        const windowStart = new Date(window.start);
        windowStart.setHours(0, 0, 0, 0);

        const windowEnd = new Date(window.end);
        windowEnd.setHours(23, 59, 59, 999); // Set to end of day

        // Check if appointment date falls within window date range
        if (appointmentDate >= windowStart &amp;&amp; appointmentDate &lt;= windowEnd) {
          console.log(
            `Appointment on ${appointmentDate.toDateString()} is within window: ${windowStart.toDateString()} to ${windowEnd.toDateString()}`
          );
          return true;
        }
      }
    }

    console.log(
      `Appointment on ${appointmentDate.toDateString()} is outside all visit windows`
    );
    return false;
  };

  /**
   * Handles proceeding with booking an appointment outside the visit window after confirmation.
   * @returns {void}
   */
  // If confirm on outside study window pop up
  const proceedWithOutOfWindowBooking = () => {
    if (!pendingAppointment) return;
    handleAddAppointment(pendingAppointment, true); // override
    setOutsideWindowPopupOpen(false);
    setPopupOpen(false);
    setPendingAppointment(null);
  };

  /**
   * Handles clearing the search and window events on the calendar.
   * @returns {void}
   */
  // Clear search and window on calender
  const handleClearWindow = () => {
    setWindowEvents([]);
    setSearchPatientId("");
    setCurrentPatient(null);
  };

  /**
   * Handles confirming the deletion of an event from the booked events list.
   * @returns {void}
   */
  // Confirm delete on pop up, append to local storage
  const confirmDeleteEvent = () => {
    if (!eventToDelete?.patientId) {
      console.error("Missing patientId on event", eventToDelete);
      return;
    }

    const updatedEvents = bookedEvents.filter(
      (event) =>
        event.id !== eventToDelete.id || event.start !== eventToDelete.start
    );

    setBookedEvents(updatedEvents);
    localStorage.setItem("bookedEvents", JSON.stringify(updatedEvents));

    // If booking deleted then reset visit and type as its now a window again
    const updatedUser = userList.map((p) => {
      if (p.id === eventToDelete.patientId) {
        return {
          ...p,
          type: "window",
          visitNum: Math.max(1, p.visitNum - 1),
        };
      }
      return p;
    });

    // Set and store after booking delete
    setUserList(updatedUser);
    localStorage.setItem("userInfoList", JSON.stringify(updatedUser));
    setPopupOpen(false);

    // Will close edit popup if event is deleted
    closePopup();
    setEventToDelete(null);
    setShowRebookingForm(false);
    setAppOpen(false);
  };

  /**
   * Handles clicking on an event in the calendar to open the delete confirmation popup.
   * @param {Object} event - The event object that was clicked.
   * @return {void} 
   */
  // Store event clicked on and open pop up for delete
  const handleEventClick = (event) => {
    setEventToDelete(event);
    setPopupOpen(true);
  };

  /**
   * Handles adding a new appointment by opening the appointment booking popup.
   * @return {void}
   */
  // Store event clicked on and open pop up for delete
  const handleEventAdd = () => {
    setAppOpen(true);
  };

  /**
   * State to manage booked appointments.
   * @type {Array&lt;Object>} 
   * @returns {void} Does not return a value.
   * 
   */
  // Create array to store booked appointments
  const [bookedEvents, setBookedEvents] = useState(() => {
    // Place in local storage + make date object to store
    const stored = localStorage.getItem("bookedEvents");
    if (stored) {
      try {
        const parsed = JSON.parse(stored);
        return parsed.map((event) => ({
          ...event,
          start: new Date(event.start),
          end: new Date(event.end),
        }));
      } catch (error) {
        // Return error message
        console.error("Failed to parse bookedEvents from storage:", error);
        return [];
      }
    }
    return [];
  });

  // Sets current date and time
  const localizer = momentLocalizer(moment);

  /**
   * Hand;es adding a new appointment to the booked events list and updating patient context.
   * 
   * @param {Object} appointment - The appointment object containing details for the new appointment. 
   * @param {boolean} [override=false] - Flag indicating whether to override visit window checks. 
   * @returns {void} Does not return a value.
   */
  // Function to add appointment
  const handleAddAppointment = (appointment, override = false) => {
    //validate required fields
    if( !appointment.start || !appointment.end || !appointment.patientId){
      console.error("Missing required appointment fields:", appointment);
      setAlert({
        message: "Missing required appointment fields.",
        type: "error",
      });
      setAppOpen(false);
      return;
    }

    if (!appointment.room){
      setAlert({
        message: "Please select a room for the appointment.",
        type: "error",
      });
      setAppOpen(false);
      return;
    }

    const patientId = appointment.patientId;
    // Find patient Id
    const patient = userList.find((p) => p.id === patientId);

    if (!patient){
      setAlert({
        message: `Patient ID ${patientId} not found in user list.`,
        type: "error",
      });
      setAppOpen(false);
      return;
    }

    //Check if the date is blocked
    const isBlocked = blockedDates.some((blocked) =>
      moment(appointment.start).isSame(blocked.start, "day")
    );

    if (isBlocked) {
      setAlert({
        message: "Cannot book appointment on a blocked date",
        type: "error",
      });
      setAppOpen(false);
      return;
    }

    // Check if its within the visit window
    if (!override &amp;&amp; !isAppointmentWithinVisitWindow(appointment, patient)) {
      setPendingAppointment(appointment);
      setOutsideWindowPopupOpen(true);
      return;
    }

     // If trying to book another appointment for patient
    if (bookedEvents.some((e) => e.patientId === patientId)) {
      setAlert({
        message: "This patient already has a booked appointment.",
        type: "error",
      });
      return;
    }

     const nextVisitNum = (patient.visitNum ?? 1);
    
    // Add new appointment object structure
    const fullAppointment = {
      ...appointment,
      title: `${patient.Study}| ID: ${patientId}`,
      Study: appointment.Study || patient.Study || "UNKNOWN",
      patientId,
      Name: patient.Name,
      DOB: patient.DOB,
      site: patient.site,
      OutOfArea: patient.OutOfArea,
      Info: patient.Info,
      start: new Date(appointment.start), 
      end: new Date(appointment.end), 
      type: "booked", // As no longer window
      visitNum: nextVisitNum,
      id: patientId,
      room: appointment.room,
      notes: appointment.notes,
    };

    // Update bookedEvents state including the new appointment
    setBookedEvents(prevBooked => {
      const updatedBooked = [...prevBooked, fullAppointment];

      // Save to localStorage with conversion to string for dates
      const updatedBookedForStorage = updatedBooked.map(evt => ({
        ...evt,
        start: new Date(evt.start).toISOString(),
        end: new Date(evt.end).toISOString(),
      }));

      localStorage.setItem(
        "bookedEvents",
        JSON.stringify(updatedBookedForStorage)
      );

      return updatedBooked.map(evt=> ({
        ...evt,
        start: new Date(evt.start),
        end: new Date(evt.end),
      })); // this updates the state
    });

    // Context updater
    updatePatient(patientId, {
      title: `${patient.Study}| ID: ${patientId}`,
      type: "booked",
      visitNum: nextVisitNum + 1,
      start: appointment.start.toISOString(),
      end: appointment.end.toISOString(),
      notes: appointment.notes,
    });

    // Tell user appointment is booked
    setAlert({ message: "Appointment booked successfully.", type: "success" });
    setAppOpen(false);
  };

  /**
   * State to manage selected rooms for filtering appointments.
   * @type {Array&lt;{id: string, label: string}>} 
   * @returns {void} Does not return a value.
   */
  // Selected rooms available
  const roomList = [
    { id: "TeleRoom", label: "Telemetry Room (Room 2.10)" },
    { id: "room1", label: "Assessment Room 1" },
    { id: "room2", label: "Assessment Room 2" },
    { id: "room3", label: "Assessment Room 3" },
    { id: "room4", label: "Assessment Room 4" },
    { id: "devRoom", label: "Developmental Assessment Room (Room 2.07)" },
  ];

  // Replace study filter state with rooms filter
  const [selectedRooms, setSelectedRooms] = useState(
    roomList.map((room) => room.id)
  );

  // Handler for room checkbox change
  const handleRoomChange = (roomId) => {
    setSelectedRooms((prev) =>
      prev.includes(roomId)
        ? prev.filter((r) => r !== roomId)
        : [...prev, roomId]
    );
  };

  const blockedEvents = blockedDates.map((evt) => {
    return {
      title: "Blocked",
      start: new Date(evt.start),
      end: new Date(evt.end),
      allDay: true,
      blocked: true,
    };
  });

  /**
   * Cleans up past appointments by removing them from bookedEvents and updating userList accordingly.
   * @returns {void} Does not return a value.
   */
  const cleanupPastAppointments = useCallback(() => {
    const now = new Date();
    let updatedBookedEvents = [...bookedEvents];
    let updatedUserList = [...userList];
    let userListChanged = false;

    updatedUserList = updatedUserList.map((user) => {
      const userAppointments = bookedEvents.filter(
        (e) => e.patientId === user.id
      );
      const latestAppointment = userAppointments.sort(
        (a, b) => new Date(b.end) - new Date(a.end)
      )[0];

      if (latestAppointment &amp;&amp; new Date(latestAppointment.end) &lt; now) {
        updatedBookedEvents = updatedBookedEvents.filter(
          (e) => e.id !== latestAppointment.id
        );
        userListChanged = true;

        return {
          ...user,
          type: "window",
          visitNum: (user.visitNum ?? 1) + 1,
        };
      }
      return user;
    });
    // Only update state and localStorage if changes occurred
    if (userListChanged || updatedBookedEvents.length !== bookedEvents.length) {
      setBookedEvents(updatedBookedEvents);
      setUserList(updatedUserList);

      localStorage.setItem("bookedEvents", JSON.stringify(updatedBookedEvents));
      localStorage.setItem("userInfoList", JSON.stringify(updatedUserList));
    }
  }, [bookedEvents, userList]);

  // Run on state changes
  useEffect(() => {
    cleanupPastAppointments();
  }, [cleanupPastAppointments]);

  // Run automatically every 15 minutes
  useEffect(() => {
    const interval = setInterval(() => {
      cleanupPastAppointments();
    }, 15 * 60 * 1000); // 15 mins in ms

    return () => clearInterval(interval); // cleanup on unmount
  }, [cleanupPastAppointments]);

  /**
   * Combines all event types into a single array for calendar display and applies filtering based on selected rooms.
   * @returns {Array&lt;Object>} Array of filtered appointment objects for calendar display.
   * 
   */
  // Array of all avents
  const allEvents = [...bookedEvents, ...windowEvents, ...blockedEvents];

  /**
   * Filters appointments based on selected rooms and ensures date objects are properly formatted.
   * 
   * @returns {Array&lt;Object>} Array of filtered appointment objects with proper date formatting.
   */
  const filteredAppointments = useMemo(() => {
    return allEvents
    .filter((event) => {
      if (event.blocked) return true;
      if (event.type === "window") return true; // Always show windows
      return selectedRooms.includes(event.room); // Filter booked by room
    })
    .map((evt) => ({
      ...evt,
      start: evt.start instanceof Date ? evt.start : new Date(evt.start),
      end: evt.end instanceof Date ? evt.end : new Date(evt.end),
    }));
  }, [allEvents, selectedRooms]);

  const dayPropGetter = (date) => {
    const isBlocked = blockedDates.some((evt) => moment(date).isSame(evt.start, "day"));
    if (isBlocked) {
      return {
        style: { backgroundColor: "#ff0015ff" }, 
        className: "blocked-date-cell",
      };
    };

    return{};
  }

  const DateCellWrapper = ({children, value, onSelectSlot}) => {
    const isBlocked = blockedDates.some((evt) => moment(value).isSame(evt.start, "day"));

    return (
    &lt;div 
    style={{
      backgroundColor: isBlocked ? "ff0015ff" : "transparent",
      height: "100%",
      width: "100%",
      cursor: "pointer"
    }} onClick={() => onSelectSlot &amp;&amp; onSelectSlot({ start: value })}>
      {children}
    &lt;/div>
    );
  };

  //-------------------------------------------HTML------------------------------------------------------------------

  // API loading or error message if encountered
  if (loading) return &lt;div>Loading appointments...&lt;/div>;
  if (error) return &lt;div>Error loading appointments: {error.message}&lt;/div>;

  return (
    &lt;div className="CalBody">
      {alert &amp;&amp; (
        &lt;Alert
          message={alert.message}
          type={alert.type}
          onClose={() => setAlert(null)}
        />
      )}

      {/**CALENDER*/}
      &lt;div className="calendar-wrapper">
        &lt;Calendar
          localizer={localizer}
          events={filteredAppointments}
          startAccessor="start"
          endAccessor="end"
          eventPropGetter={combinedEventGetter}
          view={view}
          onView={setView}
          date={date}
          onNavigate={setDate}
          dayPropGetter={dayPropGetter}
          blockedDates={blockedDates}
          onSelectSlot={(slotInfo) => {
            setDate(slotInfo.start);
            setView("day");
          }}
          onSelectEvent={handleSelectEvent}
          selectable
          views={["month", "week", "day", "agenda"]}
          components={{
            event: ({ event }) => (
              &lt;div>
                {event.title}
                &lt;div style={{ fontSize: 14 }}>
                  &lt;strong>
                    {new Date(event.start).toLocaleTimeString([], {
                      hour: "2-digit",
                      minute: "2-digit",
                    })}
                  &lt;/strong>{" "}
                  -{" "}
                  &lt;strong>
                    {new Date(event.end).toLocaleTimeString([], {
                      hour: "2-digit",
                      minute: "2-digit",
                    })}
                  &lt;/strong>
                &lt;/div>
                &lt;div style={{ fontSize: 12 }}>
                  &lt;strong>{event.notes}&lt;/strong>
                &lt;/div>{" "}
                {/* Show description here */}
              &lt;/div>
            ),
            toolbar: CustomToolbar,
            dateCellWrapper: DateCellWrapper,
          }}
        />
      &lt;/div>

      &lt;div className="floatContainer">
        {/**WINDOW SEARCH*/}
        &lt;div className="floatChild">
          &lt;h4>Show Event Types&lt;/h4>
          &lt;div className="filter-row">
            &lt;div className="windowView">
              &lt;label>
                View Patient Window:
                &lt;input
                  type="text"
                  placeholder="Enter Patient ID"
                  value={searchPatientId}
                  onChange={(e) => setSearchPatientId(e.target.value)}
                />
                &lt;div className="button-row">
                  &lt;button
                    className="search-button"
                    onClick={handleSearchWindow}
                  >
                    Search Window
                  &lt;/button>
                  &lt;button className="clear-button" onClick={handleClearWindow}>
                    Clear Window
                  &lt;/button>
                &lt;/div>
                &lt;div className="blockContainer">
                  &lt;label>
                    Select Date to Block:
                    &lt;input
                      type="date"
                      value={selectedDate}
                      onChange={handleDateChange}
                    />
                  &lt;/label>
                  &lt;div className="button-row">
                    &lt;button onClick={handleBlockDate} className="block-button">
                      {" "}
                      Block Date
                    &lt;/button>
                    &lt;button
                      onClick={handleShowBlockedDates}
                      className="block-button"
                    >
                      {showBlockedDates ? "Hide" : "Show"} blocked dates
                    &lt;/button>
                    &lt;button className="block-button" onClick={handleUnBlockDate}>
                      Unblock Date
                    &lt;/button>
                  &lt;/div>
                  {showBlockedDates &amp;&amp; (
                    &lt;ul>
                      {blockedDates.map((date, index) => (
                        &lt;li key={index}>
                          {moment(date.start).format("YYYY-MM-DD")}
                        &lt;/li>
                      ))}
                    &lt;/ul>
                  )}
                &lt;/div>
              &lt;/label>
              {/**DISPLAYS PATIENT WHEN SEARCHED IN WINDOW*/}
              {currentPatient &amp;&amp; (
                &lt;div className="patientInfo">
                  &lt;h4>Patient Info&lt;/h4>
                  &lt;p>
                    &lt;b>ID:&lt;/b> {currentPatient.id}
                  &lt;/p>
                  &lt;p>
                    &lt;b>Visit Number:&lt;/b> {currentPatient.visitNum}
                  &lt;/p>
                  &lt;p>
                    &lt;b>DOB:&lt;/b>{" "}
                    {new Date(currentPatient.DOB).toLocaleDateString(
                      undefined,
                      {
                        year: "numeric",
                        month: "long",
                        day: "numeric",
                      }
                    )}
                  &lt;/p>
                &lt;/div>
              )}
            &lt;/div>
          &lt;/div>
        &lt;/div>

        &lt;div>
          {/**COLLAPSABLE FILTER BOX*/}
          &lt;div className="floatChild">
            &lt;ul>
              &lt;li>
                &lt;div>
                  &lt;b>Room Filter&lt;/b>
                &lt;/div>
                {/**DISPLAYS FILTERS USING LOOP*/}
                &lt;ul>
                  {roomList.map((room) => (
                    &lt;li key={room.id}>
                      &lt;div className="filter-checkbox">
                        &lt;label>
                          &lt;input
                            type="checkbox"
                            checked={selectedRooms.includes(room.id)}
                            onChange={() => handleRoomChange(room.id)}
                            className={room.id}
                          />
                          {room.label}
                        &lt;/label>
                      &lt;/div>
                    &lt;/li>
                  ))}
                &lt;/ul>
              &lt;/li>
            &lt;/ul>
          &lt;/div>
        &lt;/div>
        &lt;div className="floatButton">
          &lt;h4>Book an Appointment&lt;/h4>

          &lt;button className="appButton" onClick={handleEventAdd}>
            &lt;CiCalendar className="bookIcon" />
          &lt;/button>
          &lt;div className="patientInfo">
            &lt;p>
              &lt;strong>Tip:&lt;/strong> Click the calendar icon to add a new
              appointment.
            &lt;/p>
            &lt;p>Use the filter to the left to specify room viewings.&lt;/p>
            &lt;p>
              And try out the search window or block features to view patient
              visit windows and block dates for your schedule.
            &lt;/p>
          &lt;/div>
        &lt;/div>
      &lt;/div>

      {/**EDIT POPUP*/}
      {selectedEvent &amp;&amp; (
        &lt;div className="popup-overlay">
          &lt;div className="popup-content">
            &lt;div className="popup-header">
              &lt;h3>
                Edit Event for {selectedEvent.Name || selectedEvent.title}
              &lt;/h3>
            &lt;/div>
            &lt;label>
              Title:
              &lt;input
                type="text"
                value={editedInfo.title}
                onChange={(e) =>
                  setEditedInfo((prev) => ({ ...prev, title: e.target.value }))
                }
              />
            &lt;/label>

            &lt;label>
              Start:
              &lt;input
                type="datetime-local"
                value={moment(editedInfo.start).format("YYYY-MM-DDTHH:mm")}
                onChange={(e) =>
                  setEditedInfo((prev) => ({
                    ...prev,
                    start: new Date(e.target.value),
                  }))
                }
                className="date-edit"
              />
            &lt;/label>

            &lt;label>
              End:
              &lt;input
                type="datetime-local"
                value={moment(editedInfo.end).format("YYYY-MM-DDTHH:mm")}
                onChange={(e) =>
                  setEditedInfo((prev) => ({
                    ...prev,
                    end: new Date(e.target.value),
                  }))
                }
                className="date-edit"
              />
            &lt;/label>

            &lt;label>
              Room:
              &lt;select
                id="room"
                name="room"
                value={editedInfo.room}
                onChange={(e) =>
                  setEditedInfo((prev) => ({ ...prev, room: e.target.value }))
                }
              >
                &lt;option value="">-- Select Room --&lt;/option>
                &lt;option value="TeleRoom">Telemetry Room (Room 2.10)&lt;/option>
                &lt;option value="room1">Assessment Room 1&lt;/option>
                &lt;option value="room2">Assessment Room 2&lt;/option>
                &lt;option value="room3">Assessment Room 3&lt;/option>
                &lt;option value="room4">Assessment Room 4&lt;/option>
                &lt;option value="devRoom">
                  Developmental Assessment Room (Room 2.07)
                &lt;/option>
              &lt;/select>
            &lt;/label>

            &lt;label className="checkbox-container">
              &lt;input
                type="checkbox"
                checked={editedInfo.noShow}
                onChange={handleNoShowChange}
              />
              &lt;span className="noshow-check">&lt;/span>
              Mark as No-Show / Cancelled
            &lt;/label>

            {showRebookingForm &amp;&amp; selectedEvent &amp;&amp; (
              &lt;RebookingForm
                event={selectedEvent}
                onSave={(updatedEvent) => {
                  handleUpdateEvent(updatedEvent);
                  setShowRebookingForm(false);
                }}
                onCancel={() => setShowRebookingForm(false)}
              />
            )}

            &lt;div className="button-row">
              &lt;button onClick={saveEditedInfo} className="confirm-button">
                Save
              &lt;/button>
              &lt;button onClick={closePopup} className="cancel-button">
                Cancel
              &lt;/button>
              &lt;button
                onClick={() => handleEventClick(selectedEvent)}
                className="delete-button"
              >
                Delete Appointment
              &lt;/button>
            &lt;/div>
          &lt;/div>
        &lt;/div>
      )}

      {/**DELETE POPUP*/}
      &lt;PopUp
        isOpen={popupOpen}
        onClose={() => setPopupOpen(false)}
        onConfirm={() => {
          confirmDeleteEvent();
        }}
        message={`Delete ${eventToDelete?.title || "this event"} for ${
          eventToDelete?.patientId || "Unknown ID"
        }?`}
        option1="Confirm"
        option2="Cancel"
      />
      {/*EDIT POPUP*/}
      &lt;PopUp
        isOpen={rebookPopupOpen}
        onClose={() =>{
          setRebookPopupOpen(false);
          setAppOpen(false);
        } }
        onConfirm={() => {
          openBookingFormWithPrefill(eventToRebook);
          setRebookPopupOpen(false);
        }}
        message={`This event was marked as a no-show. Would you like to rebook for ${
          eventToRebook?.patientId || "this patient"
        }?`}
        option1="Yes"
        option2="No"
      />

      {/**APPOINTMENT BOOKING FORM*/}
      &lt;div className="AppointmentToggle">
        &lt;ToggleAppointment
          onAddAppointment={handleAddAppointment}
          isOpen={appOpen}
          onClose={() => setAppOpen(false)}
          bookedEvents={bookedEvents}
        />
      &lt;/div>

      {/**Pop up for window booking warning*/}
      &lt;PopUp
        isOpen={outsideWindowPopupOpen}
        onClose={() => setOutsideWindowPopupOpen(false)}
        onConfirm={proceedWithOutOfWindowBooking}
        message={`This event for patient ${pendingAppointment?.patientId} is outside of the visit window. Do you wish to proceed?`}
        option1="Confirm"
        option2="Cancel"
      />
    &lt;/div>
  );
};

export default MyCalendar;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#MyCalendar">MyCalendar</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Mon Nov 10 2025 12:28:58 GMT+0000 (Greenwich Mean Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
